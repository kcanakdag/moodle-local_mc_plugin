{"version":3,"file":"connection_status.min.js","sources":["../../../src/local/admin/connection_status.js"],"sourcesContent":["/**\n * Connection status module for the admin settings page.\n *\n * Handles status display and polling using Mustache templates\n * for dynamic UI updates.\n *\n * @module     local_mc_plugin/local/admin/connection_status\n * @copyright  2025 Kerem Can Akdag\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([\n    'local_mc_plugin/local/admin/selectors',\n    'local_mc_plugin/local/admin/repository',\n    'local_mc_plugin/local/admin/event_selector',\n    'local_mc_plugin/local/admin/templates',\n    'core/str'\n], function(Selectors, Repository, EventSelector, TemplateHelper, Str) {\n    \"use strict\";\n\n    /** @type {Object} Configuration */\n    let config = {};\n\n    /** @type {string} Event selector input ID for refreshing counter */\n    let eventInputId = '';\n\n    /** @type {HTMLElement|null} Status container element */\n    let statusContainer = null;\n\n    /** @type {HTMLElement|null} Status content element for template rendering */\n    let statusContent = null;\n\n    /**\n     * Get the count of selected events from the form.\n     *\n     * @returns {number}\n     */\n    const getSelectedEventCount = () => {\n        const eventsInput = document.querySelector(Selectors.inputs.monitoredEvents);\n        if (!eventsInput || !eventsInput.value) {\n            return 0;\n        }\n        return eventsInput.value.split(',').filter((e) => e.trim() !== '').length;\n    };\n\n    /**\n     * Get the list of selected events from the form.\n     *\n     * @returns {Array<string>}\n     */\n    const getSelectedEvents = () => {\n        const eventsInput = document.querySelector(Selectors.inputs.monitoredEvents);\n        if (!eventsInput || !eventsInput.value) {\n            return [];\n        }\n        return eventsInput.value.split(',').map((e) => e.trim()).filter((e) => e !== '');\n    };\n\n\n    /**\n     * Build sync status text based on selected and synced events.\n     *\n     * @param {number} syncedCount Number of synced events\n     * @param {Array} syncedEvents Array of synced event names\n     * @returns {Promise<string|null>} Sync status text or null\n     */\n    const buildSyncStatusText = async(syncedCount, syncedEvents) => {\n        const selectedCount = getSelectedEventCount();\n        const selectedEvents = getSelectedEvents();\n\n        if (syncedCount === 0) {\n            return await Str.get_string('status_events_not_synced', 'local_mc_plugin');\n        }\n\n        if (syncedCount === selectedCount && syncedEvents) {\n            const allMatch = selectedEvents.every((e) => syncedEvents.includes(e));\n            if (allMatch) {\n                const str = await Str.get_string('status_events_synced', 'local_mc_plugin', syncedCount);\n                return str;\n            }\n        }\n\n        // Events changed\n        return await Str.get_string('status_events_changed', 'local_mc_plugin');\n    };\n\n    /**\n     * Update the status display using template rendering.\n     *\n     * @param {boolean} connected Whether connected\n     * @param {string|null} siteName Site name if connected\n     * @param {number} syncedCount Number of synced events\n     * @param {Array} syncedEvents Array of synced event names\n     * @param {string|null} message Error message if not connected\n     */\n    const updateStatus = async(connected, siteName, syncedCount, syncedEvents, message) => {\n        if (!statusContent) {\n            return;\n        }\n\n        // Update event selector with synced events\n        EventSelector.setSyncedEvents(syncedEvents);\n\n        let statusText;\n        let syncStatus = null;\n\n        if (connected) {\n            statusText = await Str.get_string('status_connected', 'local_mc_plugin');\n            syncStatus = await buildSyncStatusText(syncedCount, syncedEvents);\n\n            // Refresh event selector counter\n            if (eventInputId) {\n                EventSelector.refreshCounter(eventInputId);\n            }\n        } else {\n            statusText = message || await Str.get_string('status_not_connected', 'local_mc_plugin');\n        }\n\n        // Build context and render template\n        const context = TemplateHelper.buildConnectionStatusContext(\n            connected,\n            statusText,\n            siteName,\n            syncStatus\n        );\n\n        await TemplateHelper.renderConnectionStatus(statusContent, context);\n    };\n\n    /**\n     * Sync events in the background and update status.\n     */\n    const syncEventsInBackground = async() => {\n        try {\n            const syncResult = await Repository.syncEvents(config.syncUrl, config.sesskey);\n\n            if (syncResult.success) {\n                // Refresh connection status to show updated sync count\n                const data = await Repository.getConnectionStatus(config.syncUrl, config.sesskey);\n                if (data.connected) {\n                    await updateStatus(true, data.site_name, data.synced_event_count || 0, data.synced_events || []);\n                }\n            }\n            // Silently ignore sync failures - user can manually sync if needed\n        } catch (err) {\n            // Silently ignore errors - connection status already shows current state\n        }\n    };\n\n    return {\n        /**\n         * Test the connection and update status.\n         *\n         * @param {boolean} autoSync Whether to automatically sync events after connection check\n         */\n        testConnection: async function(autoSync) {\n            autoSync = autoSync || false;\n            if (!statusContent) {\n                return;\n            }\n\n            // Show loading state - render with checking text\n            const checkingText = await Str.get_string('connect_initializing', 'local_mc_plugin');\n            const loadingContext = {\n                connected: false,\n                statusclass: 'text-muted',\n                dotclass: 'text-muted',\n                statustext: checkingText,\n                hassitename: false,\n                hassyncstatus: false,\n            };\n            await TemplateHelper.renderConnectionStatus(statusContent, loadingContext);\n\n            try {\n                const data = await Repository.getConnectionStatus(config.syncUrl, config.sesskey);\n\n                if (data.connected) {\n                    await updateStatus(true, data.site_name, data.synced_event_count || 0, data.synced_events || []);\n\n                    // Auto-sync events if requested and connected\n                    if (autoSync) {\n                        await syncEventsInBackground();\n                    }\n                } else if (data.error) {\n                    await updateStatus(false, null, 0, [], data.error);\n                } else if (data.configured) {\n                    const msg = await Str.get_string('status_click_connect', 'local_mc_plugin');\n                    await updateStatus(false, null, 0, [], msg);\n                } else {\n                    const msg = await Str.get_string('status_click_connect_link', 'local_mc_plugin');\n                    await updateStatus(false, null, 0, [], msg);\n                }\n            } catch (err) {\n                await updateStatus(false, null, 0, [], err.message);\n            }\n        },\n\n        /**\n         * Update status with an error message (for sync failures).\n         *\n         * @param {string} errorMessage The error message\n         */\n        updateStatusWithError: async function(errorMessage) {\n            if (!statusContent) {\n                return;\n            }\n\n            const syncFailedText = await Str.get_string('status_sync_failed', 'local_mc_plugin');\n            const context = {\n                connected: false,\n                statusclass: 'text-danger',\n                dotclass: 'text-danger',\n                statustext: syncFailedText,\n                hassitename: false,\n                syncstatus: errorMessage,\n                hassyncstatus: true,\n            };\n\n            await TemplateHelper.renderConnectionStatus(statusContent, context);\n        },\n\n        /**\n         * Initialize the connection status module.\n         *\n         * @param {Object} [cfg] Optional configuration object\n         */\n        init: function(cfg) {\n            cfg = cfg || null;\n            // Find the status container\n            statusContainer = document.querySelector(Selectors.status.container);\n\n            if (statusContainer) {\n                // Read config from data attributes\n                config = {\n                    syncUrl: statusContainer.dataset.syncurl || (cfg && cfg.syncUrl) || '',\n                    sesskey: statusContainer.dataset.sesskey || (cfg && cfg.sesskey) || '',\n                };\n                eventInputId = statusContainer.dataset.eventinputid || (cfg && cfg.eventInputId) || '';\n\n                // Find the content area for template rendering\n                statusContent = statusContainer.querySelector(Selectors.status.content);\n            } else if (cfg) {\n                // Fallback to passed config (backward compatibility)\n                config = cfg;\n                eventInputId = cfg.eventInputId || '';\n            }\n\n            // Initial status check with auto-sync enabled\n            this.testConnection(true);\n        }\n    };\n});\n"],"names":["define","Selectors","Repository","EventSelector","TemplateHelper","Str","config","eventInputId","statusContainer","statusContent","buildSyncStatusText","async","syncedCount","syncedEvents","selectedCount","eventsInput","document","querySelector","inputs","monitoredEvents","value","split","filter","e","trim","length","getSelectedEventCount","selectedEvents","map","getSelectedEvents","get_string","every","includes","updateStatus","connected","siteName","message","statusText","setSyncedEvents","syncStatus","refreshCounter","context","buildConnectionStatusContext","renderConnectionStatus","testConnection","autoSync","loadingContext","statusclass","dotclass","statustext","hassitename","hassyncstatus","data","getConnectionStatus","syncUrl","sesskey","site_name","synced_event_count","synced_events","syncEvents","success","err","syncEventsInBackground","error","configured","msg","updateStatusWithError","errorMessage","syncstatus","init","cfg","status","container","dataset","syncurl","eventinputid","content"],"mappings":"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"}