{"version":3,"file":"connection_status.min.js","sources":["../../../src/local/admin/connection_status.js"],"sourcesContent":["/**\n * Connection status module for the admin settings page.\n *\n * Handles status display and polling using Mustache templates\n * for dynamic UI updates.\n *\n * @module     local_mc_plugin/local/admin/connection_status\n * @copyright  2025 Kerem Can Akdag\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([\n    'local_mc_plugin/local/admin/selectors',\n    'local_mc_plugin/local/admin/repository',\n    'local_mc_plugin/local/admin/event_selector',\n    'local_mc_plugin/local/admin/templates',\n    'core/str'\n], function(Selectors, Repository, EventSelector, TemplateHelper, Str) {\n    \"use strict\";\n\n    /** @type {Object} Configuration */\n    let config = {};\n\n    /** @type {string} Event selector input ID for refreshing counter */\n    let eventInputId = '';\n\n    /** @type {HTMLElement|null} Status container element */\n    let statusContainer = null;\n\n    /** @type {HTMLElement|null} Status content element for template rendering */\n    let statusContent = null;\n\n    /**\n     * Build sync status text based on synced events count.\n     *\n     * @param {number} syncedCount Number of synced events\n     * @returns {Promise<string|null>} Sync status text or null\n     */\n    const buildSyncStatusText = async(syncedCount) => {\n        if (syncedCount === 0) {\n            return await Str.get_string('status_events_not_synced', 'local_mc_plugin');\n        }\n\n        return await Str.get_string('status_events_synced', 'local_mc_plugin', syncedCount);\n    };\n\n    /**\n     * Update the status display using template rendering.\n     *\n     * @param {boolean} connected Whether connected\n     * @param {string|null} siteName Site name if connected\n     * @param {number} syncedCount Number of synced events\n     * @param {Array} syncedEvents Array of synced event names\n     * @param {string|null} message Error message if not connected\n     */\n    const updateStatus = async(connected, siteName, syncedCount, syncedEvents, message) => {\n        if (!statusContent) {\n            return;\n        }\n\n        // Update event selector with synced events\n        EventSelector.setSyncedEvents(syncedEvents);\n\n        let statusText;\n        let syncStatus = null;\n\n        if (connected) {\n            statusText = await Str.get_string('status_connected', 'local_mc_plugin');\n            syncStatus = await buildSyncStatusText(syncedCount);\n\n            // Refresh event selector counter\n            if (eventInputId) {\n                EventSelector.refreshCounter(eventInputId);\n            }\n        } else {\n            statusText = message || await Str.get_string('status_not_connected', 'local_mc_plugin');\n        }\n\n        // Build context and render template\n        const context = TemplateHelper.buildConnectionStatusContext(\n            connected,\n            statusText,\n            siteName,\n            syncStatus\n        );\n\n        await TemplateHelper.renderConnectionStatus(statusContent, context);\n    };\n\n    /**\n     * Sync ALL events in the background and update status.\n     * This syncs all available Moodle events to MoodleConnect,\n     * allowing users to create triggers for any event.\n     */\n    const syncAllEventsInBackground = async() => {\n        try {\n            const syncResult = await Repository.syncAllEvents(config.syncUrl, config.sesskey);\n\n            if (syncResult.success) {\n                // Refresh connection status to show updated sync count\n                const data = await Repository.getConnectionStatus(config.syncUrl, config.sesskey);\n                if (data.connected) {\n                    await updateStatus(true, data.site_name, data.synced_event_count || 0, data.synced_events || []);\n                }\n            }\n            // Silently ignore sync failures - user can manually sync if needed\n        } catch (err) {\n            // Silently ignore errors - connection status already shows current state\n        }\n    };\n\n    return {\n        /**\n         * Test the connection and update status.\n         *\n         * @param {boolean} autoSync Whether to automatically sync events after connection check\n         */\n        testConnection: async function(autoSync) {\n            autoSync = autoSync || false;\n            if (!statusContent) {\n                return;\n            }\n\n            // Show loading state - render with checking text\n            const checkingText = await Str.get_string('connect_initializing', 'local_mc_plugin');\n            const loadingContext = {\n                connected: false,\n                statusclass: 'text-muted',\n                dotclass: 'text-muted',\n                statustext: checkingText,\n                hassitename: false,\n                hassyncstatus: false,\n            };\n            await TemplateHelper.renderConnectionStatus(statusContent, loadingContext);\n\n            try {\n                const data = await Repository.getConnectionStatus(config.syncUrl, config.sesskey);\n\n                if (data.connected) {\n                    await updateStatus(true, data.site_name, data.synced_event_count || 0, data.synced_events || []);\n\n                    // Auto-sync ALL events if requested and connected\n                    if (autoSync) {\n                        await syncAllEventsInBackground();\n                    }\n                } else if (data.error) {\n                    await updateStatus(false, null, 0, [], data.error);\n                } else if (data.configured) {\n                    const msg = await Str.get_string('status_click_connect', 'local_mc_plugin');\n                    await updateStatus(false, null, 0, [], msg);\n                } else {\n                    const msg = await Str.get_string('status_click_connect_link', 'local_mc_plugin');\n                    await updateStatus(false, null, 0, [], msg);\n                }\n            } catch (err) {\n                await updateStatus(false, null, 0, [], err.message);\n            }\n        },\n\n        /**\n         * Update status with an error message (for sync failures).\n         *\n         * @param {string} errorMessage The error message\n         */\n        updateStatusWithError: async function(errorMessage) {\n            if (!statusContent) {\n                return;\n            }\n\n            const syncFailedText = await Str.get_string('status_sync_failed', 'local_mc_plugin');\n            const context = {\n                connected: false,\n                statusclass: 'text-danger',\n                dotclass: 'text-danger',\n                statustext: syncFailedText,\n                hassitename: false,\n                syncstatus: errorMessage,\n                hassyncstatus: true,\n            };\n\n            await TemplateHelper.renderConnectionStatus(statusContent, context);\n        },\n\n        /**\n         * Initialize the connection status module.\n         *\n         * @param {Object} [cfg] Optional configuration object\n         */\n        init: function(cfg) {\n            cfg = cfg || null;\n            // Find the status container\n            statusContainer = document.querySelector(Selectors.status.container);\n\n            if (statusContainer) {\n                // Read config from data attributes\n                config = {\n                    syncUrl: statusContainer.dataset.syncurl || (cfg && cfg.syncUrl) || '',\n                    sesskey: statusContainer.dataset.sesskey || (cfg && cfg.sesskey) || '',\n                };\n                eventInputId = statusContainer.dataset.eventinputid || (cfg && cfg.eventInputId) || '';\n\n                // Find the content area for template rendering\n                statusContent = statusContainer.querySelector(Selectors.status.content);\n            } else if (cfg) {\n                // Fallback to passed config (backward compatibility)\n                config = cfg;\n                eventInputId = cfg.eventInputId || '';\n            }\n\n            // Initial status check with auto-sync enabled\n            this.testConnection(true);\n        }\n    };\n});\n"],"names":["define","Selectors","Repository","EventSelector","TemplateHelper","Str","config","eventInputId","statusContainer","statusContent","updateStatus","async","connected","siteName","syncedCount","syncedEvents","message","statusText","setSyncedEvents","syncStatus","get_string","buildSyncStatusText","refreshCounter","context","buildConnectionStatusContext","renderConnectionStatus","testConnection","autoSync","loadingContext","statusclass","dotclass","statustext","hassitename","hassyncstatus","data","getConnectionStatus","syncUrl","sesskey","site_name","synced_event_count","synced_events","syncAllEvents","success","err","syncAllEventsInBackground","error","configured","msg","updateStatusWithError","errorMessage","syncstatus","init","cfg","document","querySelector","status","container","dataset","syncurl","eventinputid","content"],"mappings":";;;;;;;;;;AAUAA,uDAAO,CACH,wCACA,yCACA,6CACA,wCACA,aACD,SAASC,UAAWC,WAAYC,cAAeC,eAAgBC,SAI1DC,OAAS,GAGTC,aAAe,GAGfC,gBAAkB,KAGlBC,cAAgB,WAyBdC,aAAeC,MAAMC,UAAWC,SAAUC,YAAaC,aAAcC,eAClEP,yBAODQ,WAFJd,cAAce,gBAAgBH,kBAG1BI,WAAa,KAEbP,WACAK,iBAAmBZ,IAAIe,WAAW,mBAAoB,mBACtDD,gBA9BoBR,OAAAA,aACJ,IAAhBG,kBACaT,IAAIe,WAAW,2BAA4B,yBAG/Cf,IAAIe,WAAW,uBAAwB,kBAAmBN,aAyBhDO,CAAoBP,aAGnCP,cACAJ,cAAcmB,eAAef,eAGjCU,WAAaD,eAAiBX,IAAIe,WAAW,uBAAwB,yBAInEG,QAAUnB,eAAeoB,6BAC3BZ,UACAK,WACAJ,SACAM,kBAGEf,eAAeqB,uBAAuBhB,cAAec,gBAyBxD,CAMHG,eAAgBf,eAAegB,aAC3BA,SAAWA,WAAY,GAClBlB,2BAMCmB,eAAiB,CACnBhB,WAAW,EACXiB,YAAa,aACbC,SAAU,aACVC,iBALuB1B,IAAIe,WAAW,uBAAwB,mBAM9DY,aAAa,EACbC,eAAe,SAEb7B,eAAeqB,uBAAuBhB,cAAemB,0BAGjDM,WAAahC,WAAWiC,oBAAoB7B,OAAO8B,QAAS9B,OAAO+B,YAErEH,KAAKtB,gBACCF,cAAa,EAAMwB,KAAKI,UAAWJ,KAAKK,oBAAsB,EAAGL,KAAKM,eAAiB,IAGzFb,eAhDchB,yBAEDT,WAAWuC,cAAcnC,OAAO8B,QAAS9B,OAAO+B,UAE1DK,QAAS,OAEdR,WAAahC,WAAWiC,oBAAoB7B,OAAO8B,QAAS9B,OAAO+B,SACrEH,KAAKtB,iBACCF,cAAa,EAAMwB,KAAKI,UAAWJ,KAAKK,oBAAsB,EAAGL,KAAKM,eAAiB,KAIvG,MAAOG,QAqCaC,QAEP,GAAIV,KAAKW,YACNnC,cAAa,EAAO,KAAM,EAAG,GAAIwB,KAAKW,YACzC,GAAIX,KAAKY,WAAY,OAClBC,UAAY1C,IAAIe,WAAW,uBAAwB,yBACnDV,cAAa,EAAO,KAAM,EAAG,GAAIqC,SACpC,OACGA,UAAY1C,IAAIe,WAAW,4BAA6B,yBACxDV,cAAa,EAAO,KAAM,EAAG,GAAIqC,MAE7C,MAAOJ,WACCjC,cAAa,EAAO,KAAM,EAAG,GAAIiC,IAAI3B,WASnDgC,sBAAuBrC,eAAesC,kBAC7BxC,2BAKCc,QAAU,CACZX,WAAW,EACXiB,YAAa,cACbC,SAAU,cACVC,iBALyB1B,IAAIe,WAAW,qBAAsB,mBAM9DY,aAAa,EACbkB,WAAYD,aACZhB,eAAe,SAGb7B,eAAeqB,uBAAuBhB,cAAec,UAQ/D4B,KAAM,SAASC,KACXA,IAAMA,KAAO,KAEb5C,gBAAkB6C,SAASC,cAAcrD,UAAUsD,OAAOC,WAEtDhD,iBAEAF,OAAS,CACL8B,QAAS5B,gBAAgBiD,QAAQC,SAAYN,KAAOA,IAAIhB,SAAY,GACpEC,QAAS7B,gBAAgBiD,QAAQpB,SAAYe,KAAOA,IAAIf,SAAY,IAExE9B,aAAeC,gBAAgBiD,QAAQE,cAAiBP,KAAOA,IAAI7C,cAAiB,GAGpFE,cAAgBD,gBAAgB8C,cAAcrD,UAAUsD,OAAOK,UACxDR,MAEP9C,OAAS8C,IACT7C,aAAe6C,IAAI7C,cAAgB,SAIlCmB,gBAAe"}